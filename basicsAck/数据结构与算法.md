# 数据结构与算法

## 一、时间复杂度与空间复杂度

### 1、时间复杂度

### 2、空间复杂度

​       

## 二、排序算法

![image-20200904000332279](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200904000332279.png)

### 1、冒泡排序

时间复杂度：O(n^2)

```java
public static void sort(int[] arr){
    //先完全遍历，将最大值放到最后
    //在遍历n-1，将次大值放到n-1的位置；
    for(int i = arr.length-1; i > 0; i--){
        for(int j = 0; j < i; j++){
            if(arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

```

### 2、选择排序

时间复杂度：O(n^2)

把合适的元素放到合适的位置：（交换）

​                             把最小的放在first，把first交换到后边

​                             把二小的放在second...............

不断挑出最小的值放在合适的位置，缩小范围

```java
public static void sort(int[] arr){
    //前一个元素到n-2;
    for(int i = 0; i < arr.length - 1; i++){
        int temp = i;
         //后一个元素到n-1；
        for(int j=i+1; j<arr.length; j++){
            if(arr[temp] > arr[j]){
                temp = j;
            }
        }
       swap(arr,i,temp);
    }
}

private static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### 3、插入排序

时间复杂度：O(n^2)

后边较小的数，插到前边合适的位置：

挨个比较，不断插入，每个位置都插入一次

```java
public static void sort(int[] arr){
     //从第二个数开始  和第一个数开始比较
    for(int i = 1; i < arr.length; i++){
        //和前边的数比较
        for(int j = i; j > 0; j--){  
            if(arr[j] < arr[j-1]){
                int temp = arr[j-1];
                arr[j-1] = arr[j];
                arr[j] = temp;
            }
        }
    }
}
```



### 4、希尔排序

时间复杂度：比插入排序好

插入排序的改良版，交换的元素不再是相邻元素，而是相隔h的元素，初始h<n/2；

```java
public static void sort(int[] arr){
    int h = 1;
    while(h < arr.length/2){
        h = 2*h+1;
    }
    while(h>=1){
        //首先找到第一个待插元素
        for(int i = h; i < arr.lenth; i++){
            //找到每个待插元素对应的前边的元素
            for(int j=i; j>=h;j-=h){
                if(arr[j] < arr[j-h]){
                    int temp = arr[j];
                    arr[j] = arr[j-h];
                    arr[j-h] = temp;
                }else{
                    break;
                }
            }
        }
        //缩小间隔
        h = h/2;
    }
}
```



### 5、归并排序

时间复杂度：O(nlogn)

原理是**递归**（自己调用自己）

![image-20200810175859278](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200810175859278.png)



### 6、快速排序

分治

时间复杂度：最优O(nlogn)    最差O(n^2)

找到一个分界值，大的放右边，小的放左边，最后合并

![image-20200810181753118](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200810181753118.png)



```java
public class QuickSort{
    public static void quickSort(int[] arr, int left, int right){
        int r = right;
        int l = left;
        int mid = arr[(right + left) / 2];
        int temp = 0;
        while(l <= right){
            while(arr[l] < mid){
                l++;
            }
            while(arr[r] > mid){
                r--;
            }
            if( l > r){
                break;
            }
            temp = arr[r];
            arr[r] = arr[l];
            arr[l] = temp;
            if(arr[l] == mid){
                r-=1;
            }
            if(arr[r] == mid){
                l+=1;
            }
        }
        if(l == r){
            l++;
            r--;
        }
        if(left < r){
            quickSort(arr,left,r);
        }
        if(right > l){
            quickSort(arr,l,right);
        }
    }
}
```





### 7、排序的稳定性

稳定：冒泡排序、插入排序、归并排序

不稳定：选择排序、希尔排序、快速排序、堆排序



## 三、线性表



​        







## 四、树

完全二叉树：叶子节点只能出现在最底层或次底层









## 五、图

### 1、图的表示方法

   邻接矩阵、邻接表

### 2、图的遍历

#### 2.1、深度优先遍历（DFS）

#### 2.2、广度优先遍历（BFS）



## 六、算法

### 1、KMP

​      字符串匹配问题

### 2、贪心算法



### 3、Prim算法（普里姆算法）

   最小生成树问题

### 4、克鲁斯卡尔算法

   最小生成树问题：先将边按权值排序，依次构建最小权值树，但是避免出现回路



### 5、弗洛伊德算法