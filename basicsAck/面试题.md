

##### 面试题

##### 一、Java数据类型及运算符

###### 1、8中基本数据类型

| 类型    | 字节（byte） | 位（bit） |
| ------- | ------------ | --------- |
| byte    | 1            | 8         |
| short   | 2            | 16        |
| int     | 4            | 32        |
| long    | 8            | 64        |
| flout   | 4            | 32        |
| double  | 8            | 64        |
| char    | 2            | 16        |
| boolean | 1            | 8         |

###### 2、运算符

①左移运算符 <<   右边空位用0补齐

②有符号右移>>     左边空位符号位补齐

③无符号右移>>>   左边空位用0补齐

④&   |   ~   ^



##### 二、集合

###### 1、常见集合

Map接口和Collection接口；

Collection接口的子接口主要有Set和List接口

Map接口的主要实现类包括：HashMap、TreeMap、Hashtable、ConcurrentHashMap

Set接口的主要实现类包括：HashSet、TreeSet、LinkedHashSet

List接口的主要实现类包括：ArrayList、LinkedList、Stack、Vector

List和数组之间的转换：List转换为数组：toArray();

​                                         数组转换为List：asList(); 

###### 2、ArrayList和LinkedList、Vector的区别

①都继承了List接口，Vector线程安全(扩容为2倍)

②ArrayList基于数组，查找快，不需要移动指针；初始化容量为10，扩容机制为1.5倍

③LinkedList基于链表，插入、删除快；原因是：每个节点有两个引用，分别指向前一个节点和后一个节点。



###### 3、HashMap和Hashtable、currentHashMap

①Hashtable使用synchronized实现同步，线程安全

②HashMap没有考虑同步，线程不安全，允许null存储

③HashMap默认容量为16，负荷系数为0.75，扩容为原来的2倍，在JDK1.8后新增红黑树，链表个数超过8转换为红黑树，底层结构为：**数组+链表+红黑树**

④ConcurrentHashMap线程安全，并且锁分离

⑤LinkedHashMap，保存插入顺序

⑥TreeMap实现SortMap接口，默认升序排列



###### 4、Iterator接口

所有的集合类都实现了Iterator接口，用于遍历集合中元素

主要方法：hasNext();    next();    remove();



###### 5、Comparable和Comparator比较器

两个都是接口需要implements

①Comparable接口：内部实现比较器，需要实现后**重写**compareTo(T t); 方法

`@Override`

`public int compareTo(Object another){}`

②Comparator接口：外部实现比较器，需要实现后自定义conpare(a,b)；方法

###### 6、扩容机制

①List初始容量为10，加载因子为0.5，扩容为原来的1.5倍

②Set初始容量为16，加载因子为0.75，扩容为原来的2倍

③Map初始容量为16，加载因子为0.75，扩容为原来的2倍



###### 7、fail-fast机制

Java集合的错误检测机制，当线程1通过Iterator遍历集合时，如果线程2对集合进行了修改，会抛出异常



###### 8、HashSet的实现原理

hashSet是基于hashMap实现的，hashMap底层是用数组+链表+红黑树实现，当链表长度大于8时，转换为红黑树。



###### 9、==和equals

①==：基本数据类型：比较值是否相同

​            引用数据类型：比较引用是否相同

②equals:  一般比较的是值是否相同







##### 三、面向对象

###### 1、final、finally、finalize的区别

final定义的变量为常量，不可改变

final定义的方法不可重写

final定义的类不可被继承

finally用于异常处理中，finally后的语句块存放的语句肯定会执行

finalize()是垃圾处理机制中的一种方法，在对象被回收前调用

###### 2、重载和重写

①重载是在同一个类中，方法名相同，但是**参数列表不同**

②重写是在不同类中，子类实现父类方法，方法名、参数列表都相同，只是方法体不同；

​     在子类中调用父类中被重写的方法，需要用super关键字       

###### 3、抽象类和接口

抽象类和接口都不能直接实例化

①抽象类需要被继承(extends)；可以做方法申明和实现；

抽象类中可以有普通成员变量；可以包含非抽象方法；

可以有构造器

②接口需要被实现(implements)；只能做方法申明；

接口中没有普通成员变量；接口中的方法都必须是抽象的

不可以有构造器

###### **4、反射**

对于任意一个类，都能够知道这个类的所有属性和方法；

对于任意一个对象，都能调用这个对象的任意属性和方法；

①获取类的Class对象：.getClass();        .class();

​                                        Class.forName("包名.类名")

②获取类的Fields(属性值)：

getField();   getFields();   返回public的属性，包括父类中的

getDeclaredField(); getDeclaredFields();   不包括父类中的

③获取类的Method：

getMethod(); getMethods()

getDeclaredMethod();   getDeclaredMethods()



###### 5、Class.forName()与ClassLoader.loadClass()的区别

①Class.forName()，会执行该类静态块中的内容，进行初始化

②ClassLoader.loadClass()，不会执行该类静态块中的内容



###### 6、单例设计模式

```
//调用单例模式，创建对象
public class SingleTonTest{
    public static void main(String[] args){
        singleTone1 st = singleTon1.getInstace();
    }
}
```

①饿汉式（线程安全）

```java
class singleTon1(){
    //1/私有化类的构造器
    private singleTon1(){}
    //2/内部创建类的对象
    private static singleTon1 istance = new singleTon1();
    //3/提供公共的方法，返回类的对象
    public static singleTon1 getInstance(){
        return instance;
    }
}
```

②懒汉式(延迟创建对象，相对饿汉式加载时间短)

（加入synchronized使其线程安全）

```java
class singleTon2(){
    //1、私有化类的构造器
    private singleTon2(){}
    //2、声明当前类对象，没有初始化
    private static singleTon2 instance = null；
    //3、提供公共方法，返回类的对象
    public synchronized static singleTon2 getInstance(){
        if(instance == null){
            instance = new singleTon2();
        } 
        return instance;
    }
}
```

```java
//双重锁
public class SingleTon{
    private SingleTon(){}
    private volatile static SingleTon instance = null;
    public static SingleTon getInstace(){
        if(instance == null){
            synchronized(SingleTon.class){
                if(instance == null){
                    instance = new SingleTon();
                }
            }
        }
        return instance;
    }
}
```



###### 7、深拷贝和浅拷贝

①深拷贝：拷贝整个对象，分别独立，修改互不影响

②浅拷贝：拷贝地址，一个修改，全部影响；.colne();



###### 8、序列化与反序列化

实现Serializable接口

需要定义serialVersionUID = 11L; 保证反序列化的成功进行

①序列化：将数据结构或对象转换为字节流的过程，可以将其保存在磁盘文件或通过网络发送；

②反序列化：读取文件，将字节流转换为对象



###### 9、hashcode和equals

equals相等的两个对象，hashcode一定相等；

hashcode相等的两个对象不一定equals相等。



###### 10、String、StringBuffer、StringBuilder的区别

String定义的字符串，长度不可改变

StringBuffer定义的字符串长度可以改变，是线程安全的，可通过append()、insert()、reverse()操作字符串

StringBuilder定义的字符串长度可以改变，是非线程安全的。

###### 11、String常用类

charAt();      indexof();     replace();    trim();    split();

length();     getBytes();     toLowerCase();   woUpperCase();



###### 12、字符串反转

```
StringBuffer stringBuffer = new StringBuffer();
stringBuffer.append("abcdefg");
sout(stringBuffer.reverse());

StringBuilder stringBuilder=new StringBuilder();
stringBuilder.append("abcdefg");
sout(stringBuilder.reverse());
```

###### 13、static关键字

- static一般用来修饰成员变量或函数

- static修饰内部类，普通类不允许声明为静态

  可以通过外部类.内部类来声明变量，再调用内部类方法

- static修饰方法，可以直接通过类名调用方法

- static修饰变量，类变量，可以使用类名直接调用

- static修饰代码块，加载完类后会直接执行，在主方法之前执行





##### 四、线程

###### 1、创建线程的四种方式

①extends Thread类，重写run()方法

②implements Runnable接口，重写run()方法，通过Thread对象调用start()

③实现Callable接口，重写call()方法，可以返回值，可以抛出异常，支持泛型

④线程池



###### 2、线程的同步

①synchronized对代码块进行同步

②synchronized对方法进行同步

③Lock锁



###### 3、线程通信的三种方法

必须在同步代码块或同步方法中使用，三种方法定义在Object类中：（因为三种方法是对象级的，不是线程级的）

wait();   阻塞

notify();  唤醒一个

notifyAll();   唤醒全部



###### 4、sleep()和wait()的区别

①一旦执行，都使当前线程进入阻塞状态

②sleep()；声明在Thread类中，不会自动释放锁

③wait();    声明在Object类中，自动释放锁，必须在同步代码块或同步方法中使用



###### 5、线程的生命周期

new;   新建

start;  就绪

运行

阻塞: sleep();  wait(); join();--------notify();notifyAll()

stop;  死亡



###### 6、并行和并发

①并行：多个CPU同时执行多个任务

②并发：一个CPU同时执行多个任务



###### 7、线程和进程

①线程是进程的一个实体，一个进程可以拥有多个线程’

②线程之间可以共享地址和资源，可以进行通信



###### 8、死锁

①死锁产生条件：

​     互斥条件：一个资源每次只能被一个进程使用；

​     请求与保持条件：一个进行因请求资源而阻塞时，对已获得的资源保持不放；

​     不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺；

​     循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系；

②如何避免死锁：指定获取锁的顺序，阻止循环等待



###### 9、volatile关键字

①当某一个线程对被volatile关键字修饰的变量进行修改后，其他线程可以看见这个修改（可见性）

②不保证原子性

③禁止指令重排序（因为volatile修饰的变量可能会发生改变，所以变量的位置不可以改变，例如提前到其他语句之前，这样可能会出错，所以禁止指令重排序）



###### 10、Lock和Synchronized的区别

①Lock需要手动释放锁；基于java编写；可以实现synchronized所有的功能

②synchronized自动释放锁；基于jvm底层实现



###### 11、悲观锁和乐观锁

①悲观锁：假设每次处理数据的时候都会有人去修改，所以在操作之前都会上锁：synchronized和Lock都是悲观锁

②乐观锁：假设每次处理数据的时候都不会有人去修改，所以不会上锁，但是在操作之前会判断一下在此期间是否有人去更新数据。



###### 12、start()和run() 的区别

①start()：启动一个新的线程，不可重复调用；start()之后，线程处于就绪状态，不会马上运行，等CPU空闲的时候调用run()方法去运行。

②run() ： 没有执行多线程，直接运行，和普通成员方法一样，可以被重复调用



###### 13、ThreadLocal

线程的本地化对象：将线程对象保存到本地，在本地进行更新，不会影响其他线程；在本地保存使用ThreadLocalMap，保存形式为[ThreadLocal,对象值]



###### 14、怎样确保三个线程T1、T2、T3按顺序执行

使用join()方法，在线程T3中调用T2，在T2中调用T1，这样T1先执行，执行完后T2执行，最后T3执行



###### 15、Thread类中的yield方法的作用

暂停正在执行的线程对象，让其他拥有相同优先级的线程执行



###### 16、线程优先级

1—10之间的整数，10是最高优先级

1-----MIN_PRIPRITY

5-----NORM_PROPRITY

10---MAX_PROPRITY



###### 17、常见线程池

①newSingleThreadExecutor

   单个线程的线程池，每次只有一个线程工作

②newFixedThreadExecutor(n)

​    固定数量的线程池，每提交一个任务就是一个线程

③newCacheThreadExecutor

​    可缓存线程池，当线程池大小超过了处理任务所需的线程，就会回收部分空闲线程，有任务来时，再添加新线程

④newScheduleThreadExecutor

​     大小无限的线程池，支持定时和周期性的执行线程



###### 18、线程池的常用参数

**使用ThreadPoolExecutor的方式创建线程池**

```java
private static ExecutorService executor = new ThreadPoolExecutor(10,10,60L,TimeUnit.SECONDS,new ArrayBlockingQueue(10));
```

①int  corePoolSize: 核心线程数量

②int maximumPoolSize:线程池允许最多线程数量

③long keepAliveTime: 线程数量超过corePoolSize,空闲线程的最大超时时间

④TimeUnit unit:超时时间单位

⑤BlockingQueue<Runnable> workQueue:工作队列，保存未执行的Runnable任务

⑥ThreadFactory threadFactory:创建线程的工厂类

⑦RejjectedExecutionHandler handler :当线程已满，工作队列也满了的时候，会被调用



###### 19、submit()和execute()方法的区别

①submit有返回值，execute没有返回值

②submit方法异常处理



###### 20、进程状态转换（进程）

![image-20200817203315820](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200817203315820.png)



##### 五、异常

###### 1、throws、throw的区别

两者都是异常处理机制中一部分

throws用在方法声明的部分，是异常处理的方式

throw是生成异常，抛出异常对象的方式

###### 2、RuntimeException

NullPointerException(NPE);

IndexOutOfBoundsException;

ArithmeticException(算术异常)；

ClassCastException(类型转换异常)；

ArrayStoreException(存放元素不符合数组类型异常)



###### 3、执行finally块的前提

①try块必须被执行

②try块或catch块中没有System.exit(0);



##### 六、网络连接

###### 1、TCP/UDP的相同与不同

相同点：都是传输层协议

①TCP面向**连接**的**流传输**控制协议，具有高可靠性，确保传输数据的正确性，有验证重发机制，传输慢

②UDP面向**无连接**的**数据报**协议，无需等待对方的应答，实时性较好，传输快

③TCP可靠的原因：发送出错时有超时重传机制、快速重传机制

###### 2、TCP的三次握手与四次挥手

①三次握手：发送方发送信息；接收方收到，并回复确认收到；发送方收到，并回复确认收到；

两次握手的话：如果接收方的确认信息丢失，发送方会一直等待，接收方也会一直等待，造成死锁

②四次挥手：客户端发送信息，请释放连接；服务器收到信息，并回复稍等，我还要传输完才行；服务器传输完，告诉客户端，传输完了，是否断开连接？；客户端收到，并回复断开连接；

###### 3、BIO、NIO、AIO

①BIO(阻塞IO)：面向流；一直等待数据就绪

②NIO(非阻塞IO)：面向缓冲区；在等待数据读取到缓冲区的同时可以干别的事

NIO核心组件：Channels(通道)、Buffers(缓冲区)、Select(选择器：一个单独的线程监视多个通道)

③AIO(异步非阻塞IO)：首先去查询，立刻返回状态；然后等待被通知去进行后续操作。

###### 4、常见HTTP状态码

200：请求成功

301：资源被永久移动到新的URI

302：资源被临时移动到新的URI

404：资源不存在

500：内部服务器错误

###### 5、URI和URl 

①URI：统一资源标志符：===URL+URN

②URL：统一资源定位符：家庭住址

③URN：姓名

###### 6、HTTP和HTTPS

应用层协议

①HTTP：超文本传输协议：不安全

②HTTPS：安全套接字层超文本传输协议：安全，通过SSL或TLS提供加密处理数据

###### 7、四层结构

应用层：HTTP数据

传输层：TCP首部【HTTP数据】

网络层：IP首部【TCP首部【HTTP数据】】

链路层：以太网首部【IP首部【TCP首部【HTTP数据】】】



###### 8、http1.0和http1.1的区别

http1.0是短连接

http1.1是长连接

###### 9、TCP安全机制

①超时重传：超过指定时间后，没有收到对方的ACK确认应答报文，就会重发该数据（数据包丢失、确认应答丢失）

②快速重传：收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段。

- SACK方法，在TCP头部加入SACK，可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据没收到，只重传丢失的数据

③滑动窗口：

④流量控制：发送方根据接收方的实际接收能力控制发送的数据量。

⑤拥塞控制

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

###### 10、DNS解析过程

- 输入域名
- 浏览器先检查自身缓存有没有对应的IP地址如果有，解析结束；如果没有下一步
- 检查操作系统中有没有对应的IP，如果有，解析结束；如果没有下一步；
- 请求本地域名服务器解析，如果有解析结束；如果没有下一步
- 请求Root Server域名服务器进行解析，根域名服务器根据Name Server 的映射关系找到目标IP，返回IP
- 找到IP后，开始建立连接



##### 七、垃圾回收机制

###### 1、判断是否需要回收

①引用计数法：引用+1；

②可达性算法：从GCroot出发，不可达及回收



###### 2、垃圾回收算法

①标记清理

​     利用可达性算法遍历，标记垃圾；然后遍历回收

②标记整理

​     利用可达性算法遍历，标记垃圾；整理然后回收

​     避免产生碎片

③复制

​     内存一分为二；A用完之后，将A中存活的复制到B；然后清理A



###### 3、分代回收算法

Java堆的结构：

| 新生代：8:1:1  | 老年代               | 永久代   |
| -------------- | -------------------- | -------- |
| 刚刚创建的对象 | 存活了一段时间的对象 | 永久存在 |

新生代：存活对象少，垃圾多----------复制回收

老年代：存活对象多，垃圾少----------标记整理

| 收集器            | 串、并行并发 | 新生、老年 | 算法          | 线程数 |
| ----------------- | ------------ | ---------- | ------------- | ------ |
| Serial（默认）    | 串行         | 新生       | 复制          | 单     |
| ParNew            | 并行         | 新生       | 复制          | 多     |
| Parallel Scavenge | 并行         | 新生       | 复制          | 单     |
| Serial Old        | 串行         | 老年       | 标记整理      | 单     |
| Paraller Old      | 并行         | 老年       | 标记整理      | 多     |
| CMS               | 并发         | 老年       | 标记清理      |        |
| G1                | 并发         | Both       | 标记整理+复制 |        |

CMS的运作过程：初始标记->并发标记->重新标记->并发清除

G1的运作过程：初始标记->并发标记->最终标记->筛选回收

##### 八、JDBC和数据库

1、常规数据库连接过程

①装载数据库驱动

②建立数据库连接

③创建数据库操作对象

④访问数据库、执行sql语句

⑤处理返回结果集（ResultSet)

⑥断开连接



###### 2、execute、executeQuery、executeUpdate

①execute返回boolean值，判断是否返回ResultSet

②executeQuery：返回一个ResultSet结果集，一般用于select

③excuteUpdate：返回受影响的行数（int），一般用于Update、Insert、Delete



###### 3、PrepareStatement和Statement的区别

①PrepareStartment是Statement的子接口

②PrepareStartment会先对sql语句进行预处理再创建对象，提高了访问速度，可实现快速批量操作

③可以操作Blob类型的数据

④防止sql注入、安全



###### 4、数据库连接池

①常用数据库连接池：C3P0、DBCP、Druid（德鲁伊）

②减少连接的创建时间

③实现统一的连接管理



###### 5、java访问数据库连接池过程

使用**Druid**连接池的优点：建立数据库连接耗时耗费资源，在大型应用中，使用数据库连接池可以重复利用数据库连接，提高对请求的响应时间和服务器的性能。

①配置文件：

url=jdbc:mysql://localhost:3306/test

username=root

password=……

driverClassName=com.mysql.jdbc.Driver

②读取配置文件，加载驱动

`private static DataSource source;`

static{

​    try{

​           Properties pros = new Properties();

​           InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("druid.properties");

​            pros.load(is);

​            source = DruidDataSourceFactory.createDataSource(pros);

​    } catch(Exception e){

​           e.printStackTrace();

​     }

③建立连接，操作数据库

   public static Connection getConnection(){

​      Connection conn = source.getConnection();

​       return conn;

​      }

}

④关闭连接



###### 6、JDBC中的ResultSet

查询完数据库返回的结果，查询结果集的数据表



###### 7、数据库类型

关系型数据库：MySQL、Oracle

非关系型型数据库(key-value键值对)：Redis



###### 8、MySQL的三种范式

①第一范式：强调原子性，每一列都不可分割

②第二范式：完全依赖主关键字

③第三范式：任何非主属性不依赖于其他非主属性



###### 9、MySQL索引及常用引擎

①索引利用B+Tree，非叶子节点不存储data，只有叶子节点存储data，叶子节点用指针连接，提高区间访问的性能

②InnoDB引擎：索引和数据存储在一起（聚集索引）；必须有主键，推荐使用整型的自增主键；支持事务、不支持全文搜索

③MyIASM引擎：索引和数据分开存储（非聚集索引）；不支持事务、支持全文搜索



###### 10、内、外连接

①内连接：inner join把匹配的关联数据显示出来

②左连接：left join 把左边的表全部显示出来

③右连接：right join把右边的表全部显示出来



###### 11、DBUtil使用

主要使用在数据库连接的关闭中，对JDBC进行了封装，简化了JDBC的编程：DBUtils.closeQuietly(conn);



###### 12、事务隔离级别

read-uncommitted

read-committed   避免脏读

repeatable-read    避免不可重复度

serializable             避免幻度



###### 13、事务的四个特征ACID

A：atomicity

C：consistency

I：isolation

D：durability



###### 14、MySQL常用查询语句

```mysql
//查询
select * from table_name where id = 1;
select distinct id form table_name;
select id,name from table_name where name like 'liu%';   有liu即可
select id,name from table_name where name like '^liu';    以liu开头
select id,name from table_name where name like 'liu$';    以liu结尾

//group_concat(xx)将按xx分组的结果写出
selcet gradeName,group_concat(Name) from student group by gradeName;

//having 用在最后
select gradeName,count(Name) from student group by gradeName having count(Name) > 3;

//limit 分页查询limit 初始位置，记录数
select * from student limit 0,5
```

```mysql
//插入
insert into table_name (a,b,c,d) values(1,2,3,4);

```

```mysql
//改
update table_name set _name_id='aa' where id=3;
//删除
delete from table_name where id=3;
```

```mysql
//两表联查
select student.name, score.score
from student
left join score
on student.id = score.id
order by student.name;
//
select * from student,score where student.id = score.id;
```

```mysql
//事务
begin;
aaa;
commit; / rollback;
```

```mysql
//添加主键
alter table table_name add primary key(col);
//删除主键
alter table table_name drop primary key(col);
```

```mysql
//求和
select sum(field) as sumValue from table_name;
//求平均值
select avg(field) as avgvalue from table_name;
//求最大值
select max(field) as maxValue from table_name;
//求最小值
select min(field) as minvalue from table_name;
```









##### 九、JAVAWeb

###### 1、Servlet的生命周期

①加载和实例化

②初始化：调用init()方法

③请求处理：调用service()方法

④服务终止：调用destroy()方法

###### 2、doget和dopost的区别：

​     doget：数据容量较小，一般用来获取数据

​     dopost：数据容量较大，一般用来提交数据

###### 3、转发和重定向

   转发：浏览器中的URL不变

   重定向：浏览器中的URL发生改变；sendRedirect();

###### 4、JQuery使用

①简化操作，不用再写繁琐的JavaScript

②按id查询：$("#id");

③按class查询：$(".class")

④用来给页面上的操作绑定事件

###### 5、JavaWeb三大组件

   servlet程序、Filter、Listener

###### 6、JSP注解

 <%!   声明脚本  %>

<%= 表达式脚本 %>

<%    代码块脚本 %>

<%--      注释      --%>

###### 7、JSP九大内置对象

request对象

response对象

pageContext对象：当前页面的上下文对象

session对象

exception对象

application对象  ：servletContext对象实例

config对象

out对象

page对象

###### 8、JSP四大域对象

pageContext    保存在同一个jsp页面使用

request             保存在同一个request对象使用

session              保存在一个会话中使用

application        保存在整个工程中









##### 十、数据结构

###### 1、栈（stack）

①先入后出

②利用栈实现综合计算器：numStack; operStack



###### 2、堆（完全二叉树）

①大顶堆：父节点大于或等于子节点

②小顶堆：父节点小于或等于子节点



###### 3、二叉树

```java
//先定义节点
class TreeNode(){
    private int node;
    private TreeNode left;
    private TreeNode right;
    public TreeNode(int node, TreeNode left, TreeNode right){
        this.node = node;
        this.left = left;
        this.right = right;
    }
}
//前序遍历
public void perOrderTraverse(TreeNode root){
    if(root != null){
        System.out.println(root.val + "->");
        perOrderTraverse(root.left);
        perOrderTraverse(root.right);
    }
}
//中序遍历
public void inOrderTraverse(TreeNode root){
    if(root != null){
        inOrderTraverse(root.left);
        System.out.println(root.val + "->")；
        inOrderTraverse(root.right);
    }
}
//后序遍历
public void postOrderTraverse(TreeNode root){
    if(root != null){
        postOrderTraverse(root.left);
        postOrderTraverse(root.right);
        System.out.println(root.val + "->")；
    }
}
```



###### 4、图

①深度优先遍历（DFS）

②广度优先遍历（BFS）













##### 十一、常用算法

###### 1、二分查找

①非递归

```java
public static int binarySearch(int[] arr, int target){
    int left = 0;
    int right = arr.length -1;
    while(left <= right){
        int mid = (right + left) / 2;
        if(arr[mid] == target){
            return mid;
        }else if(arr[mid] < target){
            left = mid + 1;
        }else{
            right = mid - 1;
        }
    }
    return -1;
}
```

②递归

```java
public static int binarySearch(int[] arr, int left, int right, int target){
    int mid = (left + right) / 2;
    if(left > right){
        return -1;
    }
    if(arr[mid] < target){
        left = mid + 1;
        return binarySearch(arr, left, right, target);
    }
    if(arr[mid] > target){
        right = mid - 1;
        return binarySearch(arr, left, right, target);
    }
    if(arr[mid] = target){
        return mid;
    } 
}
```



```java
//如果存在多个相同值
public static ArrayList<Integer> binarySearch(int[] arr, int left, int right, int target){
    int mid = (left + right) / 2;
    if(left > right){
        return new ArrayList<Integer>();
    }
    if(arr[mid] < target){
        left = mid + 1;
        return binarySearch(arr, left, right, target);
    }
    if(arr[mid] > target){
        right = mid - 1;
        return binarySearch(arr, left, right, target);
    }
    if(arr[mid] = target){
        //改进
        List<Integer> res = new ArrayList<Integer>();
        int temp = mid - 1;
        while(true){
            if(temp<0 || arr[temp] != target){
                break;
            }
            res.add(temp);
            temp -= 1;
        }
        res.add(mid)
        temp = mid + 1;
        while(true){
            if(temp>right || arr[temp] != target){
                break;
            }
            res.add(temp);
            temp += 1;
        }
    } 
}
```



###### 2、快速排序

```java
public class QuickSort{
    public static void quickSort(int[] arr, int left, int right){
        if(right <= left){
            return;
        }
        int key = arr[left];
        int l = left;
        int r = right;
        while(l <= r){
            while(key < arr[r]){
                r--;
            }
            while(key > arr[l]){
                l++;
            }
            if(l == r){
                break;
            }
            int temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;
            if(l != r){
                l++;
                r--;
            }
        }
        int temp = key;
        key = arr[l];
        arr[l] = temp;
        if(left < r){
            quickSort(arr,left,r-1);
        }
        if(right > l){
            quickSort(arr,l+1,right);
        }
    }
}
```



##### 十二、Spring

###### 1、动态代理

①JDK动态代理：要求目标类和代理类实现相同的接口

②cglib动态代理：第三方框架，不要求必须有接口



###### 2、事务的传播属性

- **PROPAGATION_REQUIRED**：如果当前没有事务，就新建一个事务；如果有事务，就加入
- PROPAGATION_SUPPORTS：支持当前事务，如果没有事务，就以非事务方式执行
- PROPAGATION_MANDATORY：使用当前事务，如果没有，抛出异常
- **PROPAGATION_REQUIRES_NEW**：新建事务，如果当前存在事务，把当前事务挂起
- PROPAGATION_NOT_SUPPORTED：以非事务方式执行，如果当前有事务，就把当前事务挂起
- PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，抛出异常
- **PROPAGATION_NESTED**：如果存在事务，则嵌套事务内执行，如果没有则新建；



###### 3、Spring配置事务的两种方法

①基于XML的事务配置

②基于注解方式的事务配置：@Transactional



###### 4、Spring的核心

①IOC：控制反转

②AOP：面向切面编程





##### 十三、Linux

###### 1、Linux文件权限

一共10位长度，分成四段：

文件类型；文件所有者权限；文件所有者所在组权限；其他用户权限



###### 2、强制卸载软件

sudo apt remove 软件包

sudo apt purge 软件包（清理配置文件）



###### 3、软件安装

在线安装：

①软件管理中心

②sudo apt install 软件包

线下安装

③网上下载 .deb文件

​    dpkg -i vim_xxxx.deb(安装vim)

​    dekg -r vim(卸载vim)



④网上下载.tar.gz包

​    tar -zxvf xxxx.tar.gz(解压)

​    cd xxxx（进入解压后的文件）

​    ./configure --prefix=/user/local/xxxx(配置安装路径)

​    {sudo apt install make

​     sudo apt install gcc}(提前配置这两个语句)

​     make(安装软件)

