## 线程：

1、 创建线程的方式：4种
   解决线程安全的方法：3种

2、 并行：多个CPU同时执行多个任务
   并发：一个CPU（采用时间片）同时执行多个任务

3、 线程的创建和使用
   java.lang.Thread
   //**创建方式一**：继承Thread
   ①创建一个继承于Thread类的子类
   ②重写Thread类的run();
   ③创建Thread类的子类的对象
   ④通过此对象调用start();

```Java 
   class MyThread extends Thread{       // ①
       public void run(){               //②
           //线程的操作声明在run()中
       }
   }
   public class ThreadTest{
       public static void main(String[] args){
           MyThread t = new MyThread();               //③
           t.start();    //启动当前线程，调用当前线程的run() ④
       }
   }
```

   //**创建方式二**：实现Runnable接口
   ①创建一个实现了Runnable接口的类
   ②实现类去实现Runnable中的抽象方法，run()
   ③创建实现类的对象
   ④将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
   ⑤通过Thread类的对象调用start()

```java
 class MThread implements Runnable{  // ①
       public void run(){            // ②
         //执行代码
       }
   }
   public class ThreadTest1{
       public static voidmain(String[] args){
            MThread MT = new MThread();     //③
            Thread t1 = new Thread(MT);     //④
            t1.start();                     //⑤
       }
   }
```

   两种方法的比较：
   Implements：共享数据；没有单继承性的局限；
   Thread类实现了Implements接口

**//创建方式三**：实现callable接口

![image-20200725202851990](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725202851990.png)



**//创建方式四**：线程池

![image-20200725203031270](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725203031270.png)



4、 常用方法
   start();
   run();
   currentThread();静态方法，返回执行当前代码的线程
   getName();获取当前线程的名字
   setName();设置当前线程的名字 // start()前设置
   yield(); 释放当前CPU的执行权
   join();在线程a中调用线程b的join()方法，a进入阻塞状态，直至b执行完，a结束阻塞
   stop();已过时，不建议使用
   sleep(x);//单位是ms，1s=1000ms,使当前线程阻塞xms
   isAlive():判断线程是否存活

5、 线程优先级
   MAX_PRIORITY: 10
   MIN_PRIORITY: 1
   NORM_PRIORITY:5
   如何设置：
   getPriority();
   setPriority(int p);

6、 线程的生命周期
   (new)新建、
   (start)就绪、
   运行、
   (sleep/join/等待同步锁/wait/suspend)阻塞(notify/notifyAll/resume)、
   (stop)死亡

![image-20200724224557405](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200724224557405.png)

7、 线程的同步
   线程安全问题：当某线程尚未操作完成，其他线程加入，进行相同操作，可能造成线程问题
   如何解决：当一个线程操作共享数据时，其他线程不能参与，必须等上一个线程操作完成
   Java：同步机制：
   ①同步代码块：
   synchronized(同步监视器){
       //需要被同步的代码
   }
   同步监视器：锁。任何一个类的对象都可以充当锁：要求多个线程必须要共用同一把锁
             最简单的直接用this:表示当前对象（实现Runnable接口专用）
                         当前类.class(继承Thread类可用)
   ②同步方法：
   当所有代码可在一个方法中包含时，直接用synchronized声明：
    public synchronized void test(){}  //锁是this
   继承Thread实现线程，需要用static修饰
    public static synchronized void test(){}   //锁是当前类本身

两个方法同步，分别用synchronized修饰

   ③Lock锁

![image-20200725201229043](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725201229043.png)    private ReentrantLock lock = new ReentrantLock();
    lock.lock();//调用锁
    lock.unlock(); //调用解锁

    synchronized：自动锁、释放
    lock:手动调用锁、释放

使用的优先顺序：lock--->同步代码块--->同步方法

   8、线程通信的三个方法

三个方法必须使用在同步代码块或同步方法中

调用者必须是同步方法中的同步监视器

三个方法定义在Object类中

wait(); 阻塞

notify(); 唤醒一个

notifyAll(); 全部唤醒

 9、面试题：sleep() 和 wait() 方法的异同

①相同点：一旦执行，都是当前的线程进入阻塞状态

②不同点：

声明位置不同：Thread类中声明sleep()；object类中声明wait();

sleep()可以在任何需要的场景下使用，wait()必须在同步代码块或同步方法中 ；

sleep()不会释放锁；wait()会释放锁；

   10、

释放锁的操作

![image-20200725202725132](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725202725132.png)

   

   不会释放锁的操作

![image-20200725202826529](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725202826529.png)



