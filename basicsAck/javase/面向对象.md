### 面向对象

#### 一、Java类及类的成员

属性、方法、构造器 ；代码块、内部类

1、面向过程：强调的是功能行为，以函数为最小单位，考虑怎样做

2、面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做

3、面向对象的两个要素：类、对象

4、面向对象程序设计的重点：类的设计

5、类的成员：

①属性 = 成员变量 = field

②方法 = 成员方法 = 函数 = method

6、类和对象的使用

①创建类，设计类的成员

②创建类的对象

③调用“对象.属性” 、“对象.方法”

7、对象的内存解析

栈（stack）：虚拟机栈， 存放局部变量

堆（heap）：存放对象

8、方法里可以调用方法，但是方法内不能定义方法

9、“万事万物皆对象”

 ①在java语言中，我们将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构

②涉及到java语言与前端、后端交互时，都体现为类、对象

10、内存解析：

引用类型的变量，只可能存储两类值：null 或 地址值

11、匿名对象

没有显式赋给一个变量名

**12、方法的重载**

①允许同一个类中，存在一个以上的同名方法，参数个数或类型、排序不同即可（同类同方法名，不同参）

②跟方法的权限修饰符、返回值类型、形参变量名、方法体没有关系

13、可变个数形参的方法

①格式：![image-20200717225750814](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200717225750814.png)

②必须声明在末尾，一个方法中最多声明一个可变个数的形参

14、**方法参数的传递机制**

数据的复制、地址的复制

![image-20200717231902012](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200717231902012.png)

15、构造器（constructor)

格式：权限修饰符  类名（形参列表）{}

public person(){}

一个类中的多个构造器，构成重载



![image-20200718221230860](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718221230860.png)



![image-20200718221443689](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718221443689.png)

![image-20200718225100662](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718225100662.png)

15、面试题：重写与重载

①二者的概念

②重载和重写的具体规则

③重载：不表现多态性； 

​    重写：表现多态性



16、“==” 和 equals()方法

“==”： 运算符
①可以使用在基本数据类型变量和引用数据类型变量中

②如果比较的基本数据类型变量，数据大小相同即可

③如果比较的引用类型变量，比较的是地址值

equals() ：方法

①比较地址值

②像String/Data/File重写了equals()方法，重写之后，比较的是实体内容是否相同。

③可以自定义重写，可以自动生成



17、toString(): 方法

①输出一个对象的引用时，就是调用了toString()方法

②String/Data/File 重写了toString()

③可以自定义toString()方法



18、包装类的使用

![image-20200719221820716](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200719221820716.png)

![image-20200719222332650](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200719222332650.png)

①使基本数据类型具有类的特征

②基本数据类型转换为包装类：Integer in1 = new Integer(i1);

③包装类转换为基本数据类型：int i1 = in1.intValue();

④**自动装箱与自动拆箱**:![image-20200719223344603](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200719223344603.png)

⑤**基本数据类型、包装类转换为****String类型**

![image-20200719223619199](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200719223619199.png)

⑥**String类型转换为基本数据类型、包装类：调用包装类的parseXxx()方法**

![image-20200719223844234](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200719223844234.png)

19、单例设计模式

①实现：饿汉式

私有化类的构造器；

内部创建类的对象；

提供公共静态方法，返回类的对象

```java
public class SingleTon{
    private static SingleTon st = new SingleTon();
    private SingleTon(){}
    public static SingleTon getSingleTon(){
        return st;
    }
}
```



②实现：懒汉式

私有化类的构造器；

声明当前类的对象；

声明public、static的返回当前类对象的方法

```java
public class SingleTon{
    private static SingleTon st = null;
    private SingleTon(){}
    public synchronized static SingleTon getInstance(){
        if(st == null){
            st = new SingleTOn();
        }
        return st;
    }
}
```

```java
//双重检验锁
public class SingleTOn{
    private volatile static SingleTOn st = null;
    private SingleTOn(){};
    
    public static SingleTon getInstance(){
        if(st == null){
            synchronized(SingleTon.class){
                if(st == null){
                    st = new SingleTOn();
                }
            }
        }
        return st;
    }
}
```











③区分：

饿汉式：对象加载时间长

​               线程安全

懒汉式：延迟去创造对象

​                线程不安全

20、代码块

![image-20200722231727800](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200722231727800.png)

21、内部类

①将类A声明在类B中，则类A为内部类，类B为外部类

②成员内部类（static、非static） VS 局部内部类（方法内、代码块内、构造器内）

③

![image-20200724213655243](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200724213655243.png)

④



#### 二、面向对象的三大特征

封装、继承、多态、（抽象）

程序设计追求：高内聚、低耦合

##### （一）封装

1、封装：

隐藏对象内部的复杂性，只对外公开简单的接口（not interface）。把该隐藏的隐藏起来，把该暴露的暴露出来，即封装的设计思想。

2、封装性的体现：将类的属性Xxx私有化，提供公共的方法来获取（getXxx）和设置（setXxx）

3、权限修饰符

private、缺省（default）、protected、public 

![image-20200718212708933](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718212708933.png)

都可以修饰：类的内部结构、属性、方法、构造器、内部类

​                       可以修饰类的：缺省、public      



##### （二）继承

1、减少了代码的冗余，提高了代码的复用性；便于功能的扩展；为多态的使用，提供了前提。

2、重写：

①在子类中，可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖，在程序执行时，子类的方法将覆盖父类的方法

②要求：

子类重写的方法，必须和父类被重写的方法具有相同的方法名称、参数列表；

子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型；

子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限；子类不能重写父类中被private修饰的方法

子类方法的异常类型不能大于父类被重写方法的异常类型

##### （三）多态

![image-20200719193822422](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200719193822422.png)

1、多态的使用：

只能调用父类中声明的方法，在运行期，实际执行的是子类重写父类的方法：左边是编译类型，右边是运行类型；

2、多态性的使用前提：

①类的继承关系②方法的重写

3、对象的多态性，只适用于方法，不适用于属性（都看左边）



##### （四）抽象

抽象类和接口

1、抽象类、抽象方法需要用abstract修饰，不可以实例化，有构造器，需要子类继承实现

![image-20200724215625844](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200724215625844.png)



2、接口使用interface定义，接口中不能定义构造器，不可实例化，可以继承接口

需要用implements实现，需要用类去实现其中所有的抽象方法，然后才可以实例化

①代理模式

②工厂模式

3、JDK8中接口的新特性：出了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法；

接口中定义的静态方法，只能通过接口调用；

实现接口的类，new的对象可以调用默认方法；

子类（实现类）继承的父类和实现的接口中声明了同名同参数的方法，子类没有重写的话，会调用父类中的方法；

调用接口中的默认方法 :   interface.super.method();

![image-20200724215357481](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200724215357481.png)

4、抽象类和接口的共同点和区别

①都不能实例化、都可以被继承

②抽象类有构造器，接口没有构造器







#### 三、其他关键字

this/super/static/final/abstract/interface/package/import

##### 1、this

①修饰属性或方法：代表当前对象![image-20200718222414435](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718222414435.png)

②在构造器中，可以调用this代表正在创建的对象

③利用this调用构造器

格式：this(形参列表)；必须声明在首行

![image-20200718223131069](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718223131069.png)

##### 2、package

![image-20200718225733984](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718225733984.png)

##### 3、import

![image-20200718225804060](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200718225804060.png)

##### 4、super

![image-20200719191642912](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200719191642912.png)

调用父类的构造器：super(形参列表)；调用父类中相同形参列表的构造器；必须声明在子类构造器的首行。

##### 5、instanceof

①向下转型，使用强制类型转换符：Man m1 = (Man) P2;

②使用强转时，可能出现ClassCastException的异常

③使用instanceof：

​    格式： a  instanceof A 

​    判断对象a是否是类A的实例，如果是，返回true

​                                                       如果不是，返回false

##### 6、关键字static

①可以用来修饰：属性、方法、代码块、内部类

②是否用static修饰，可以分为静态属性（类   变量）vs非静态属性（实例变量）

非静态属性：每个对象独立拥有一套类中的非静态属性

静态属性：多个对象共享一个静态变量，一个对象修改，会影响其他对象的变量

③静态变量随着类的加载而加载，早于对象的创建

④由于类只会加载一次，所以静态变量在内存中只会存在一份，存在方法区的静态域中

⑤静态方法中只能调用静态方法或属性

非静态方法中都可调用

⑥在静态方法内，不可使用this/super

⑦如何确定一个属性是否声明为static

属性被多个对象所共享时

⑧如何确定一个方法是否声明为static

操作静态属性的方法，通常设置为static

工具类中的方法通常声明为static，例如：Math/Array/Collections

##### 7、final

![image-20200722232854487](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200722232854487.png)















