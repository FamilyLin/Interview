异常的父类：java.lang.Throwable；
分为：编译时异常；运行时异常；
编译时异常：除(RuntimeException)如：IOException；FileNotFoundException.......
运行时异常：RuntimeException：NullPointException;ArrayIndexOutOfBoundException;
                          ClassCastException;NumberFormatException;...

1、try - catch - finally
try{
   //可能出现异常的代码
}catch（异常类型 变量名）{
  //处理异常
  //String getMessage()； //输出异常
  //printStackTrace()；   //追溯异常
  e.getMessage();
  e.printStackTrace();
}
finally{
  //可选部分
  //即使前边出现问题，本部分也会执行
  //优先级高于前边的 return
  //主要用于手动资源释放，避免前边代码出现问题不可关闭
}

2、throws + 异常类型  ：  写在方法声明处，声明异常（抓）
public void method() throws 异常类型{
  //可能出现异常的代码
  //异常后代码不执行
}
一直向上抛异常，直至main块（方法的调用者），需要在main块中用try - catch 解决

3、如何选择
①子类重写方法抛出的异常不能大于父类方法的异常；父类没有使用throws，子类不可使用throws，只能使用 try - catch
②调用递进关系的方法时，使用throws

4、手动抛出异常（throw）：生成异常对象（抛）
if(true){
  //执行代码
}else{
  throw new RuntimeException("手动抛出异常");
}

5、自定义异常类
①继承现有异常：RuntimeException；Exception
②提供全局变量：serialVersionUID（可查看现有异常类）标识异常类
③提供重载构造器
public class MyException extends RuntimeException{
  private static final long serialVersionUID = 12315468743123112L;
  public MyException(){}
}

6、尽量处理编译时异常，运行时异常处理代码

7、面试题
final/finally/finalize
throw/throws:throws:异常处理方式；throw：生成异常对象，抛出异常对象
String/StringBuffer/StringBuilder
HashMap/LinkedHashMap


