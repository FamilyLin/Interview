#### 一、集合框架的概述

1、集合、数组都是对多个数据进行存储操作的结构，简称Java容器；内存方面的存储

2、数组在存储方面的特点

> 初始化后，长度就确定了；不可再修改
>
> 定义后，元素类型就确定了；
>
> 数组中的方法有限，对于添加、删除、插入非常不便
>
> 获取数组中实际元素的个数，没有现存的方法
>
> 数组存储数据：有序，可重复



#### 二、集合框架

Java集合可分为Collection和Map两种体系

Collection接口：单列数据，定义了存取一组对象的方法的集合

​            List接口：元素有序、可重复的集合；动态数组 

​                              ArrayList/LinkedList/Vector

​            Set接口：元素无序，不可重复的集合

​                               HashSet/LinkedHashSet/TreeSet

Map接口：双列数据，保存具有映射关系“key-value对"的集合

HashMap/LinkedHashMap/TreeMap/Hashtable/Properties

![image-20200725213623659](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725213623659.png)

![image-20200725213707241](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725213707241.png)

实线是继承关系；虚线是实现关系



#### 三、Collection接口中的方法的使用

1、Collection常用方法

add(Object e);       addAll(Collection coll);

size();

isEmpty(); boolean

clear();

contains(Object obj); boolean

containsAll(Collection coll);

remove(Object obj);  boolean

removeAll(Collection coll); 取差集

retainsAll(Collection coll): 取交集

equals(Object obj); boolean 

hashCode();返回当前对象的哈希值

toArray():集合-->数组

asList():数组-->集合

iterator();返回Iterator接口的实例，用于遍历集合元素

​                  iterator.next();    iterator.hasNext();

​                  iterator.remove();

向实现Collection接口的类的对象中添加数据Object时，所在类需要重写equals()方法



2、foreach和Iterator

![image-20200725224711144](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200725224711144.png)

![image-20200726090858598](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726090858598.png)

 

3、**List接口**

实现类：ArrayList、LinkedList、Vector

三者异同：

> 同：都实现了List接口，有序、可重复
>
> 不同：ArrayList：主要实现类、线程不安全
>
> ​                               底层使用Object[] 存储
>
> ​            Vector： 线程安全，底层同使用Object[]存储
>
> ​             LinkedList：底层使用双向链表存储，对于频繁的                       
>
> ​                                   插入、删除操作，效率高

4、ArrayList源码分析

ArrayList arr = new ArrayList();

initialCapacity: 10; 初始长度为10，扩容为原来的1.5倍

JDK8之后是在添加数据时才实例化，节省了内存。



5、LinkedList源码分析

LInkedList linkedlist = new LinkedList();

内部声明了Node类型的first和last属性，默认值为null



6、Vector源码分析

初始长度为10；默认扩容为原来的2倍



7、List接口常用独有的方法

ArrayList arraylist = new ArrayList();

**add**(int index, Object obj);

addAll(int index, Collection col);

**get**(int index);

indexOf(Object obj);   首次出现的位置

lastIndexOf(Object obj);   最后出现的位置

**remove**(int index); 删除指定位置的元素

**set**(int index , Object obj);

subList(int fromIndex, int toIndex);左闭右开

Iterator/foreach 遍历



8、**Set接口：**无序，不可重复；没有独有的方法

HashSet：主要实现类，线程不安全，可存储null

LinkedHashSet：HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历

TreeSet：可以按照添加元素的指定属性，进行排序

①无序性：不等于随机性，根据数据的哈希值存储

②不可重复性：保证添加的元素按照equals()判断时，不能返回true；

向Set中添加的数据，其所在类一定要重写equals()和hashCode()方法；



9、HashSet 添加元素的过程

HashSet 中的put 是在HashMap中Key的位置添加数据

①调用hashCode()方法，计算哈希值，确定存放位置

②判断此位置上是否有元素：如果没有其他元素，直接添加；如此位置有元素，首先比较hash值，如果不同则添加成功，如果相同，则用equal()方法判断：如果返回true，添加失败；如果返回false，添加成功。

注：同位置的元素，以链表的方式存储。

hashSet底层：数组+链表   （JDK7）；

​                           JDK8中底层用hashMap实现



10、LinkedHashSet

每个数据维护了两个指针：next(); prev();

优点：对于频繁的遍历操作，效率高于hashSet();



11、TreeSet()；默认升序

TreeSet TreeSet = new TreeSet();

①添加的数据，要求是相同类的对象

②两种排序方式：自然排序，定制排序

自然排序：比较是否相同：compareTo(Object obj)返回0；

定制排序：比较是否相同：compare(Object o1, Object o2) 返回0







#### 四、Map接口的框架概述

![image-20200726094608635](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726094608635.png)

HashMap:  主要实现类，线程不安全，可存储null

​                    底层：数组+链表+红黑树

> LinkedHashMap: 保证遍历map元素时，按照添加顺序遍历
>
> 原因：在原有的HashMap底层结构基础上，添加了一对指针：next(); prev();
>
> 频繁的遍历操作，执行效率高于HashMap

TreeMap: 按照添加的顺序进行排序，key的自然排序或定制排序

> 底层使用红黑树

Hashtable:  古老的实现类，线程安全

> Properties: 常用来处理配置文件，key和value都是String类型

****

#### 五、Map接口结构的理解

1、Map中的key：无序、不可重复，用set存储；key所在的类需要重写equals()、hashCode()方法

​      Map中的value：无序、可重复，用Collection存储，所在类重写equals()方法

​      一个键值对：key--value 构成一个Entry对象，用Set存储

2、**HashMap的底层实现原理**

HashMap map = new HashMap();

实例化后，底层创建了长度为16的Entry[] table；

map.put(key1, value1);

步骤：①hashCode()计算key1的哈希值，得到存放位置

​            ②如果此位置数据为空，添加成功

​            ③如果此位置数据不为空，比较key1和以及存在数据的哈希值：

如果都不同，key1-value1添加成功；

如果相同，继续比较key1类中的equals()方法：如果返回false，添加成功；如果返回true，使用value1替换之前的值

**扩容问题：默认扩容为原来的2倍**，达到临界值时扩容，加载因子：0.75；

JDK8相较上边JDK7的不同：

同ArrayList：实例化后先不创建数组，等put()时再创建数组

![image-20200726102316871](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726102316871.png)

添加红黑树的目的是为了查找简单。相当于增加了二分查找功能。



3、**LinkedHashMap的底层实现原理**

Map map = new LinkedHashMap();

在Node中增加了before，after



4、**TreeMap**:

向TreeMap中添加key_value对，要求key必须是同一类创建的对象

按key进行排序：自然排序、定制排序

TreeMap map = new TreeMap();

定制排序：

![image-20200726120017268](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726120017268.png)



#### 六、Map接口中定义的方法

Map map = new HashMap();

*put*(key , value );     *putAll*(Map   m);

*remove*(Object key);

*clear*();  清空但不是删除

*get*(Object key);   key的value

*containsKey*(Object key);

containsValue(Object value);

*size*();

*isEmpty*();

*equals*(Object obj);

***keySet***();![image-20200726114217453](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726114217453.png)

***values***();

![image-20200726114322192](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726114322192.png)

***entrySet***();

![image-20200726114513301](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726114513301.png)

![image-20200726115439098](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726115439098.png)



#### 七、Collections工具类

操作Collection、Map的工具类

1、Collection和Collections的区别

一个工具类、一个接口

2、常用方法

reverse(List); 翻转

shuffle(list);随机排序

sort(List);自然排序

sort(List,Comparetor);

swap(List , i , j);

max(Collection , Comparator);

min(Collection , Comparator);

frquency(Collection, Object); obj 出现的次数

copy(list1, list2); 将list2中的内容复制到list1中

![image-20200726181626977](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726181626977.png)

replaceAll(list, oldVal, newVal);



3、线程安全的方法

synchronizedList();

![image-20200726181722501](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726181722501.png)

synchronizedMap();





![image-20200726184539195](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726184539195.png)

 



![image-20200726233715970](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726233715970.png)



![image-20200726234104857](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726234104857.png)





