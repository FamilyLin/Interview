泛型的使用

1、jdk5.0新增

2、ArrayList<Integer> list = new ArrayList<Integer>();

在编译时，限定添加的数据为Integer类型；

​      Iterator<Integer> iterator =  list.iterator();

​       while(iterator.hasNext){}

3、泛型不同的引用不能相互赋值

4、静态方法中不可使用泛型，静态方法在载入类时载入，

​      但是泛型是类实例化时应用的，所以不可使用

5、异常类不可使用泛型

6、子父类中的泛型使用

![image-20200726211152173](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726211152173.png)

7、泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有关系；泛型方法所属的类是不是泛型类没有关系；

可以声明为静态方法，因为泛型参数是在调用方法时确定的，并非在实例化的时候确定

public 后的<E> 表明为泛型方法 

![image-20200726211719337](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726211719337.png)



8、泛型在继承方面的体现

类A和类B是子父类关系，G<A> 和G<B> 并不具备子父类关系，二者是并列关系

9、通配符的使用

通配符： ?

类A和类B是子父类关系，则可以用G<?>表示

![image-20200726213913582](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200726213913582.png)

List<?>内部不能添加数据，除null以外



10、有限制条件的通配符使用

? extends A:  <= A

? super B:       >= B