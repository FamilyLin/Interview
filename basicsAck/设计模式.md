# 设计模式

##### UML图

> 继承、实现
>
> 1、继承关系：空心三角形    +      实线
>
> 2、实现关系：空心三角形    +      虚线

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200829102847062.png" alt="image-20200829102847062" style="zoom:50%;" />

> 聚合、组合
>
> 3、聚合关系： 空心菱形        +      实线---------大学和老师
>
> 4、组合关系： 实心菱形        +      实线----------头和眼睛

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200829102914133.png" alt="image-20200829102914133" style="zoom:50%;" />

> 关联、依赖
>
> 5、关联关系： 箭头       +      实线--------老师和学生
>
> 6、依赖关系： 箭头       +      虚线--------人和手机

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200829102950302.png" alt="image-20200829102950302" style="zoom:50%;" />

##### 七大原则

> 1. 开闭原则：对外开放扩展，关闭修改
> 2. 里氏替换原则：开闭原则补充
> 3. 依赖倒置原则：针对接口编程
> 4. 单一职责原则：一个类、接口、方法只负责一项职责
> 5. 接口隔离原则：细化接口，接口中的方法尽量少
> 6. 迪米特原则：降低类与类之间的耦合
> 7. 组合聚合复用原则：先使用组合/聚合的方式，而不是继承



> 常用设计模式:
>
> 创建型：单例模式、工厂模式、抽象工厂模式
>
> 结构型：桥接模式、外观模式、代理模式
>
> 行为型：观察值模式、策略模式

##### 1、单例模式：

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200926205758675.png" alt="image-20200926205758675" style="zoom:50%;" />

```java
饿汉式
public class SingleTon{
     
     private static SingleTon st = new SingleTon();
     
     private SingleTon(){}
     
     public static SingleTon getInstance(){
         return st;
     }
}
```

```java
懒汉式
public class SingleTon{
    private static SingleTon st = null;
    private SingleTon(){}
    
    public synchronized static SingleTon getInstance(){
        if(st == null){
            st = new SingleTon();
        }
        return st;
    }
}
```

```java
双重锁
public class SingleTon{
    private volatile static SingleTon st = null;
    private SingleTon(){}
    
    public static SingleTOn getInstance(){
        if(st == null){
            synchronized(SingleTon.class){
                if(st == null){
                    st = new SingleTon();
                }
            }
        }
        return st;
    }
}
```

##### 2、工厂模式

> 工厂模式中分为：简单(普通)工厂模式

> ​                               工厂方法模式：包括静态工厂方法模式

**简单工厂模式：**一个工厂生产多个同类产品

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200926211353407.png" alt="image-20200926211353407" style="zoom:50%;" />

```java
简单工厂模式
public interface Sender{  //定义接口
    public void Send();
}

public class MailSender implements Sender{  //实现接口1
    public void Send(){
        System.out.println("this is mailSender");
    }
}

public class SmsSender implements Sender{  //实现接口2
    public void Send(){
        System.out.println("this is SmsSender");
    }
}

public class SendFactory{   //创建工厂
    public Sender Prodeuce(String type){
        if("mail".equals(type)){
            return new MailSender();
        }else if("Sms".equals(type)){
            return new SmsSender();
        }else{
            System.out.println("请输入正确的类型");
            return null;
        }
    }
}

public class FactoryTest{  //测试
    public static void main(String[] args){
        SendFactory factory = new SendFactory();
        Sender sender = factory.Produce("sms");
        sender.Send();
    }
}
```

**工厂方法模式：**不同工厂生产不同产品

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200926212519386.png" alt="image-20200926212519386" style="zoom:50%;" />

```java
工厂方法模式
public interface Sender{  //定义接口
    public void Send();
}

public class MailSender implements Sender{  //实现接口1
    public void Send(){
        System.out.println("this is mailSender");
    }
}

public class SmsSender implements Sender{  //实现接口2
    public void Send(){
        System.out.println("this is SmsSender");
    }
}

public interface Factory{  //定义接口
    public void Produce();
}

public class MailSendFactory implements Factory{   
    //创建工厂,直接定义返回方法
    public Sender Produce(){
        return new MailSender();
    }
}

public class SmsSendFactory implements Factory{
   public Sender Produce(){
        return new SmsSender();
    }
}

public class FactoryTest{  //测试
    public static void main(String[] args){
        MailSendFactory Mfactory = new MailSendFactory();
        MailSender mS = new MailSender();
        ms.Produce();
        
        SmsSendFactory Sfactory = new SmsSendFactory();
        SmsSender sS = new SmsSender();
        sS.Produce();
    }
}
```



```java
静态工厂方法模式
public interface Sender{  //定义接口
    public void Send();
}

public class MailSender implements Sender{  //实现接口1
    public void Send(){
        System.out.println("this is mailSender");
    }
}

public class SmsSender implements Sender{  //实现接口2
    public void Send(){
        System.out.println("this is SmsSender");
    }
}

public class SendFactory{   //创建工厂,直接定义静态方法
                             //调用时不需要new对象
    public static Sender MailProduce(){
        return new MailSender();
    }
    
    public static Sender SmsProduce(){
        return new SmsSender();
    }
}

public class FactoryTest{  //测试
    public static void main(String[] args){
        Sender sender = SenderFactory.MailProduce();
        sender.Send();
    }
}
```

##### 3、抽象工厂模式

**实现和依赖**

>抽象工厂模式中：指一个工厂可以生产一个公司的多种产品

> ​                               不同公司的同类产品实现相同的接口

**多个工厂，每个工厂都可以生产相同品牌，不同类的产品**

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200926213743077.png" alt="image-20200926213743077" style="zoom:50%;" />

```java
public interface Sender{ //定义发送接口
    public void send();
}
public class MailSender implements Sender{
    public void send(){
        System.out.println("this is MailSender");
    }
}
public class SmsSender implements Sender{
    public void send(){
        System.out.println("this is SmsSender");
    }
}

public interface Receiver{   //定义接收接口
    public void receive();
}
public class MailReceiver implements Receiver{
    public void receive(){
        System.out.println("this is MailReceiver");
    }
}
public class SmsReceiver implements Receiver{
    public void receive(){
        System.out.println("this is SmsReceiver");
    }
}


public interface Factory{    //定义工厂接口
    public Sender produce();
    public Receiver take();
}
public class MailFactory implements Factory{
    public Sender prodece(){
        return new MailSender();
    }    
    public Receiver take(){
        return new MailReceiver();
    }
}
public class SmsFactory implements Factory{
    public Sender produce(){
        return new SmsSender();
    }
    public Receiver take(){
        return new SmsReceiver();
    }
}

public class FactoryTest{
    public static void main(String[] args){
        Factory factory = new MsilFactory();
        Sender sender = factory.produce();
        sender.send();
    }
}
```



##### 4、桥接模式

> 组合关系
>
> 将抽象与实现分离，使他们可以独立变化。

UML图

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200926230909448.png" alt="image-20200926230909448" style="zoom:50%;" />



```java
public class BridgeTest{
    public static void main(String[] args){
        Implementor imple = new ConcreteImplementorA();
        Abstraction abs = new RefinedAbstraction(Imple);
        abs.Operation();
    }
}
//实现化角色
interface Implementor{
    public void OperationImple();
}
//具体实现化角色
class ConcreteImplementorA implements ImpleMentor{
    public void OperationImple(){
        System.out.println("具体实现化角色被访问")；
    }
}
//抽象化角色
abstract class Abstraction{
    protected Implementor imple;
    protected Abstraction(Implementor imple){
        this.imple = imple;
    }
    public abstrsct void Operation();
}
//扩展抽象化角色
class RefinedAbstraction extends Abstraction{
    protected RefinedAbstraction(Implementor imple){
        super(imple);
    }
    public void Operation(){
        System.out.println("扩展抽象化角色被访问")；
        imple.OperationImpl();
    }
}
```



##### 5、代理(Proxy)模式

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200926221452585.png" alt="image-20200926221452585" style="zoom:50%;" />



```java
public class ProxyTest{
    public static void main(String[] args){
        Proxy procy = new Proxy();
        proxy.Request();
    }
    //抽象主题
    interface Subject{
        void Request();
    }
    //真实主题
    class RealSubject implements Subject{
        public void Request(){
            System.out.println("访问真实主题方法")；
        }
    }
    //代理
    class Proxy implements Subject{
        private RealSubject realSubject;
        public void Request(){
            if(realSubject == null){
                realSubject = new RealSubject();
            }
            preRequest();
            realSubject.Request();
            postRequest();
        }
    }
    
    public void preRequest(){
        System.out.println("访问真实主题之前的预处理")；
    }
    public void postRequest(){
        System.out.println("访问真实主题之后的后续处理")；
    }
}
```



##### 6、外观模式

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200927115613667.png" alt="image-20200927115613667" style="zoom:50%;" />

```java
public class FacadePaattern{
    public static void main(String[] args){
        Facade f = new Facade();
        f.method()
    }
}
//外观
class Facade{
    private SubSystem01 obj1 = new SubSystem01();
    private SubSystem02 obj2 = new SubSystem02();
    private SubSystem03 obj3 = new SubSystem03();
    public void method(){
        obj1.method1();
        obj2.method2();
        obj3.method3();
    }
}
//子系统1
class SubSystem01{
    public void method1(){
        System.out.println("子系统01的method1（）被调用")；
    }
}

//子系统2
class SubSystem02{
    public void method2(){
        System.out.println("子系统02的method2（）被调用")；
    }
}

//子系统1
class SubSystem03{
    public void method3(){
        System.out.println("子系统03的method3（）被调用")；
    }
}

```

##### 7、策略模式

> 定义一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变换不会影响使用算法的客户。

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200927134935878.png" alt="image-20200927134935878" style="zoom:50%;" />

```java
public class StrategyPattern{
    public static void main(String[] args){
        Context c = new Context();
        Strategy s = new ConcreteStrategyA();
        c.setStrategy(s);
        c.strategyMethod();
        System.out.println("---------");
        s = new ConcreteStrategyB();
        c.setStrategy(s);
        c.strategyMethod();
    }
}
//抽象策略类
interface Strategy{
    public void strategyMethod(); //策略方法
}
//具体策略类A
class ConcreteStrategyA implements Strategy{
    public void strategyMethod(){
        System.out.println("具体策略A的策略方法被访问")；
    }
}
//具体策略类B
class ConcreteStrategyB implements Strategy{
    public void strategyMethod(){
        System.out.println("具体策略B的策略方法被访问")；
    }
}
//环境类
class Context{
    private Strategy strategy;
    public Strategy getStrategy(){
        return strategy;
    }
    public void setStrategy(Strategy strategy){
        this.strategy = strategy;
    }
    public void strategyMethod(){
        strategy.strategyMethod();
    }
}
```



##### 8、观察者模式

> 指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并被自动更新；
>
> 又被成为：发布-订阅模式；模型-视图模式

<img src="C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200927144142029.png" alt="image-20200927144142029" style="zoom:50%;" />



```java
public class ObserverPattern{
    public static void main(String[] args){
        Subject subject = new ConcreteSubject();
        Observer obs1 = new ConcreteObserver1();
        Observer obs2 = new ConcreteObserver2();
        subject.add(obs1);
        subject.add(obs2);
        subject.notifyObserver();
    }
}
//抽象目标
abstract class Subject{
    protected List<Observer> observers = new ArrayList<Observer>();
    //增加观察者方法
    public void add(Observer observer){
        observers.add(observer);
    }
    //删除观察者方法
    public void remove(Observer observer){
        observer.remove(observer);
    }
    //通知观察者方法
    public abstract void notifyObserver();
}
//具体目标
class ConcreteSubject extends Subject{
    public void notifyObserver(){
        System.out.println("具体目标发生改变");
        System.out.println("---------");
        
        for(Object obs:observers){
            ((Observer)obs).reponse();
        }
    }
}
//抽象观察者
interface Observer{
    void response(); //反应
}
//具体观察者1
class ConcreteObserver1 implements Observer{
    public void response(){
        System.out.println("具体观察着1作出反应")；
    }
}
//具体观察者2
class ConcreteObserver2 implements Observer{
    public void response(){
        System.out.println("具体观察着2作出反应")；
    }
}
```



















