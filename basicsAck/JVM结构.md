JVM总结：

![image-20200814202726957](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200814202726957.png)

1. 底层架构：

   - 字节码文件通过**类加载器**加载到运行时数据区
   - **运行时数据区**分为：堆、元空间、PC寄存器、虚拟机栈、本地方法栈
   - 运行时数据区通过**执行引擎**和CPU进行交互
   - CPU处理完后再将响应通过执行引擎返回运行时数据区

2. 类加载的过程分为：

   - 加载
   - 链接：验证、准备、解析
   - 初始化：执行类构造器方法

3. 类加载器分为四种

   - 引导类加载器：加载核心类库---以java开头
   - 扩展类加载器
   - 系统类加载器
   - 用户自定义加载器

4. 加载器的双亲委派机制

   - 如果一个类加载器收到类加载请求后，会将该请求发送到父类加载器
   - 如果父类加载器还有父类加载器，就继续往上发送，直至发送到**引导类加载器**
   - 引导类加载器判断：如果引导类加载器可以加载，则成功返回；如果不能加载，则轮到**扩展类加载器**判断，不断迭代；
   - 如果父类加载器都无法完成加载任务，子加载器尝试自己加载

5. 运行时数据区结构：

   - PC寄存器
   - 虚拟机栈
   - 本地方法栈
   - 堆空间
   - 元空间

6. PC寄存器

   - 用来存储下一条即将执行的指令的地址
   - 因为CPU需要不停的切换各个线程，切换回来之后，需要知道从哪继续执行
   - JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码执行
   - 需要记录本线程的下一条指令位置，所以是线程私有的

7. 虚拟机栈

   - 一个栈帧对应一个方法
   - 栈帧中保存方法的局部变量、部分结果，参与方法的调用和返回
   - 不存在垃圾回收问题
   - 栈的大小是动态的或是固定不变的，存在两种异常：
     - 栈的大小不变时，可能出现栈溢出异常：StackOverflowError
     - 栈的大小动态变化时，可能出现内存空间不足异常：OutOfMemoryError
   - 栈帧的内部结构包括：局部变量表、操作数栈、动态链接、方法返回地址
     1. 局部变量表：定义为一个数字数组，主要存储方法参数和定义在方法体内的局部变量
     2. 操作数栈：主要存储计算过程中的中间结果，如2+3：先把2压入栈，再将3压入栈；求和为5，2/3出栈，5入栈
     3. 动态链接：保存该栈帧方法指向运行时常量池中的引用地址
     4. 方法返回地址：记录PC寄存器中的引用地址，（正常退出后的情况下，将返回值传输到该引用地址）

8. 本地方法栈

   - 管理本地方法的调用
   - 需要和本地方法接口一起使用

9. 堆空间

   - 分为年轻代和老年代====1:2的比例
   - 年轻代分为Eden和s1/s2====8:1:1
   - 对象在堆空间的保存过程：
     1. 首先在Eden区生成新对象，Eden区满之后，启动Minor GC;
     2. 存活下来的对象，放到s1中，清空Eden；
     3. Eden再次满之后，存活的对象放到s1中，如果s1满，则将Eden存活的对象和s1中存活的对象复制到s2中；s1和s2交替执行此过程
     4. 当s1或s2中的对象年龄到达15时，放入老年代
     5. 或是当某一个Eden中的对象在s1或s2中放不下，也放到老年代
     6. 或是某个新生对象在年轻代放不下，也是直接放到老年代
     7. 如果老年代满之后，启动Major GC 或Full GC，需要根据不同的GC判断
        - Minor GC：只负责新生代的垃圾回收
        - Major GC：只负责老年代的垃圾回收
        - Mixed GC：负责新生代和老年代的垃圾回收
        - Full GC：负责堆和元空间所有的垃圾回收
   - TLAB：每个线程都有之间的Thread Local Allocation Buffer，可以避免非线程安全问题
   - 逃逸问题：在方法内new一个对象，如果没有其他变量指向他，则其是一个没有发生逃逸的对象，可以分配到栈空间中，随着方法的结束而出栈

10. 元空间

    - 并不占用JVM空间，占用本地内存空间

    - 主要存储类的信息、常量池、方法数据等
    - 字符串常量池放在堆空间中
    - 元空间的结构：
      - 常量池：存储数量值、类引用、方法引用
      - 运行时常量池：存储被虚拟机加载的类型信息、常量、静态变量等
    - 垃圾收集：常量池中废弃的常量和不再使用的类型
    - 类型不再使用需要满足的条件
      - 若该类的所有实例都被回收了
      - 加载该类的加载器已经被回收
      - 该类的.class 对象没有任何地方引用

    ![image-20200817220247615](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200817220247615.png)

11. 执行引擎

    - 解释器
      - JVM启动时，会对字节码采用逐行解释的方式执行，效率较低
    - 编译器
      - 将源代码直接编译成和本地机器平台相关的机器语言，效率高
    - 执行引擎中对解释器和编译器混合使用