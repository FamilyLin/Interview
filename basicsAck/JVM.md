# JVM

代码--->编译器--->字节码文件-->JVM--->操作系统运行

user-->字节码文件-->Jvm-->操作系统-->硬件

## 一、概述

###### 1、由于跨平台性的设计，java的指令都是根据栈来设计的 

- java编译器输入的指令流基本上是一种基于栈的的指令集架构

栈：跨平台、指令集小、指令多；执行性能比寄存器差

​        但是设计和实现较为简单

###### 2、JVM的生命周期

​     启动：引导类加载器创建一个初始类

​     执行：执行java程序时，执行的是java虚拟机进程

​     退出：正常、异常、系统错误、System.exit();

###### 3、HotSpot VM

- 通过计数器找到最具编译价值的代码，翻译为机器指令，保存在本地，方便多次调用，速度快；
- 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡



## 二、内存

### 1、内存分布

<img src="https://i.loli.net/2020/10/15/goAvbXFMkRaTxZ9.png" alt="image-20201015143152099" style="zoom:50%;" />

### 2、类加载器

| **引导类（启动类）加载器** |
| -------------------------- |
| **扩展类加载器**           |
| **系统类加载器**           |
| **用户自定义加载器**       |

- .class文件存在于本地硬盘中，由类加载器加载到内存中
- Class.forName()得到得class是已经初始化完成的
- Classloader.loaderClass得到的class是还没链接的

①类的加载过程：

- **加载**
  1. 通过一个类的全限定名来获取其定义的二进制字节流
  2. 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
  3. 在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口
- **链接：**
  1. 验证：文件格式的验证、元数据验证、字节码验证、符号引用验证
  2. 准备：为类变量分配内存并设置初始值
  3. 解析：将常量池中的符号引用转化为直接引用的过程
- **初始化**：执行类构造器方法<clinit>()

②类的加载器：四种是上下层的关系：

- **引导（启动）类**加载器----加载核心类库----以java开头
- **扩展类**加载器

​        VM自带，父类加载器是引导类加载器

- **系统类**加载器

​        加载环境变量，默认的类，父类加载器是扩展类加载器

- **用户自定义**加载器

​        隔离加载类

​        修改类的加载方式

​        扩展加载源

​        防止源码泄露

### 3、双亲委派机制

①工作原理：

- 如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
- 如果父类加载器还存在其父类加载器，就进一步向上委托，依次递归，请求最终到达顶层的**启动类加载器**
- 如果父类加载器可以完成类加载任务，就成功返回；如果父类加载器无法完成加载任务，子加载器才会尝试自己去加载

②优点：

- 避免类的重复加载
- 保护程序安全，防止核心API被随意篡改

③沙箱安全机制

​    保护核心源代码

### 4、两个class对象是否为同一个类

两个必要条件：

- 类的完整类名必须一致，包括包名
- 加载这个类的ClassLoader必须相同



## 三、运行时数据区

内存相当于是硬盘或网络    与    CPU之间的桥梁；

文件需要加载到内存中才能和CPU交互

### 1、PC寄存器（程序计数器）

①作用

​     用来存储指向**下一条即将执行的指令的地址**，指向要执行的指令代码，由执行引擎读取下一条指令。

②使用PC寄存器存储字节码指令地址的作用

​      因为CPU需要不停的切换各个线程，切换回来之后，需要知道从哪继续执行；

​      JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

③PC寄存器为什么线程私有

​     记录每个线程的下一条指令位置，不可共享

### 2、虚拟机栈

管理java方法的调用

①一个栈帧对应一个方法

②主管java程序的运行，保存方法的局部变量、部分结果，并参与方法的调用和返回

③不存在垃圾回收问题

④异常：java栈的大小是动态的或是固定不变的

- 如果采用固定大小的java虚拟机栈，那每一个线程的java虚拟机栈的容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过java虚拟机允许的最大容量，或抛出StackOverflowError异常（栈溢出）
- 如果java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，会抛出OutOfMemoryError异常（内存空间不足）

⑤栈的存储单位：栈帧

⑥**栈帧**的内部结构：

- 局部变量表
  - 定义为一个数字数组，主要存储**方法参数**和定义在方法体内的**局部变量**，包括：基本数据类型，对象引用，以及returnAddress类型
  - 局部变量表建立在线程的栈上，是私有的，不存在数据安全问题
  - 容量确定后不会改变
  - 最基本的存储单元是Slot(变量槽)
  - 32位以内的类型占一个Slot，64位的类型占两个Slot
  - Slot可以重复利用
- 操作数栈（FILO）
  - 栈：可以使用数组或链表来实现
  - 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即push/pop
  - 主要存储**计算过程中的中间结果**
- 动态链接
  - 保存一个指向运行时常量池中，该栈帧所属方法的引用
  - 栈帧可以通过动态链接，找到运行时常量池中所对应的方法。不同的栈帧可以指向同一方法，节省空间，提高效率
- 方法返回地址
  - 针对于正常退出
  - 记录的是PC寄存器的值作为返回地址，及该方法指令的下一条指令的地址

- 一些附加信息

⑦栈的面试题

- 栈溢出的情况：StackOverflowError
- 虚拟机栈中没有垃圾回收
- 方法中的局部变量是否是线程安全的？不一定
  - 只有一个线程操作，线程安全
  - 多个线程共享，并没有同步安全机制，则非线程安全
  - 方法内部产生内部消亡的对象，线程安全



### 3、本地方法接口

- 通过这些接口可以直接调用C语言的一些程序
- 因为JVM是在操作系统之上的，并不是真正的操作系统；所以还是需要调用底层C语言的一些程序



### 4、本地方法栈

管理本地方法的调用





### 5、堆

#### 5.1、堆的概述

- 一个JVM实例，只有一个堆内存；

​          

#### 5.2内存细分

①分代：年轻代、老年代、永久代（元空间）

②堆空间大小设置：       -Xms：起始内存

​                                          -Xmx：最大内存

③堆空间默认大小：  起始内存：总内存/64

​                                     最大内存：总内存/4

④年轻代与老年代

- -XX: NewRatio：用来设置新生代与老年代的比例，默认：1:2
- 如果NewRatio=4；则新生代：老年代 = 1:4；
- 新生代中：Eden:s0:s1 = 8:1:1

⑤对象分配过程

- 新生代对象分配过程
  - Eden区满之后，启动MinorGC
  - 存活对象放入s0，清空Eden
  - Eden区满之后，再次启动MinorGC
  - 如果s0满之后，放入s1;
  - 如果s区中的对象计数大于15之后，晋升到老年区

- 老年代对象分配过程
  - 老年代有一定内存，但是需要放入占更大内存的对象，此时启动FullGC/majorGC

⑥MinorGC、MajorGC、FullGC 

- 部分收集
  - Minor GC：只回收新生代垃圾，stop the world
  - Major GC：只回收老年代垃圾
  - Minxed GC：混合收集，收集整个老年代和新生代，目前只有G1有这种行为
- 整堆收集：Full GC：收集整个java堆和方法区的垃圾

⑦内存分配策略

- 优先分配到Eden
- 大对象直接分配到老年代（要避免）
- 长期存活的对象分配到老年代
- 动态对象年龄判断：当s区中所有对象总和大于s区内存一半时，放入老年代

⑧TLAB（Thread Local Allocation Buffer)

- 每个线程在Eden中都有自己的TLAB（缓冲区）
- 使用TLAB避免了非线程安全问题
- 并不是所有的对象实例都在TLAB中成功分配内存



⑩在方法内new一个对象，如果之后没有变量指向它，则该对象为没有发生逃逸的对象，可以分配到栈上，随着方法执行的结束，栈空间就被移除

```
public void my method(){
    V v = new V();
    v = null;
}
```

使用逃逸分析，编译器可以对代码进行优化：

- 如果一个对象没有发生逃逸，可以优化成**栈上分配**
- 如果一个对象被发现只能从一个线程被访问，对于这个对象可以不考虑同步，**同步省略**





### 6、方法区（元空间）



#### 6.1方法区的理解

- 方法区可以看做是一块独立于Java堆的内存空间
- 大小可以固定也可以动态扩展
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类也可能造成内存溢出OOM；例如加载大量的第三方jar包
- 关闭JVM，方法区内存自动释放
- jdk7称为永久代，占用虚拟机内存；
- jdk8称为元空间，占用本地内存

#### 6.2方法区的内部结构

①常量池-----.class字节码文件的一部分

- 数量值
- 字符串
- 类引用
- 方法引用

②运行时常量池

- 动态性：包含的数据比常量池多
- 存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存

**解释：**

- 方法区存放字节码指令及其序号
- 程序计数器中存放字节码指令的序号（即当前线程执行位置）
- 虚拟机栈中：方法栈帧中：本地变量表存放变量，操作数栈中存放当前操作的数据。

#### 6.3、方法区的垃圾收集

- 主要回收两部分内容：常量池中废弃的常量和不再使用的类型
  - 类型不再使用需要满足三个条件
    - 该类的所有实例都被回收了
    - 加载该类的加载器已经被回收
    - 该类的.Class对象没有任何地方引用





#### 6.4、运行时数据区总结





#### 7、对象实例化

#### 7.1对象创建的几种方式

#### 7.2对象创建的步骤



1. 加载类元信息
2. 为对象分配内存
3. 处理并发问题
4. 属性的默认初始化
5. 设置对象头的信息
6. 属性的显式初始化、代码块中初始化、构造器中初始化

#### 7.3对象的内存分布

①对象头：

②实例数据：



#### 7.4 对象访问定位

- 句柄指针：在堆空间中有句柄池

- 直接指针







## 四、执行引擎

- JVM核心组成部分之一

- 将字节码文件解释/编译为对应平台上的本地机器指令，从而让一个java程序运行起来

- 将高级语言翻译成机器指令

- 默认解释器和JIT编译器混合使用

  

#### 1、解释器

- 当JVM启动时，会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行。
- 效率低
- 程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行



#### 2、编译器

- JIT编译器（just in time compiler）：虚拟机将源代码直接编译成和本地机器平台相关的机器语言
- 效率高
- 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间，但是编译为本地代码后，执行效率高
- 执行频率较高的代码称为“热点代码”，基于热点探测功能，基于计数器判断次数：Client模式下是1500次，Server模式下是10000次；超过次数后激活JIT编译器编译，保存到缓存中，
- 热度衰减：一段时间内，方法被调用的次数不足1500或10000，会衰减一半



#### 3、机器码、指令、汇编语言

①机器码：二进制

②指令：机器码中特定的0和1序列

③汇编语言

④高级语言



## 五、String

- 不可变性
- String初始化之后，再次赋值也不会改变
- 字符串常量池中不会存储相同内容的字符串
- 字符串常量池底层是一个固定大小的Hashtable 

### 1、String拼接

- 如果拼接的前后都是字符串，拼接完存放在字符串常量池中
- 如果拼接的前后有一个是变量，拼接完存放在堆中，相当于new StringBuilder()
- .intern()  :判断字符串常量池中是否存在该对象，如果存在，则返回常量池中的地址；如果没有则把对象的引用地址复制一份，放入字符串常量池中，并返回字符串常量池中的引用地址；

### 2、new String("abc");

- 创建两个对象，一个是new关键字在堆空间中创建的
- 另一个是字符串常量池中的对象

#### 3、调用toString()方法，并没有在字符串常量池中生成字符串，只是在堆中新生成一个对象





## 六、垃圾回收

### 1、垃圾

- 在运行程序中没有任何指针指向的对象

### 2、垃圾标记算法

1. **引用计数算法**
   - 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性
   - 需要单独的计数器，增加了存储空间的开销
   - 无法处理循环引用的情况
2. **可达性分析算法**
   - 可以解决循环应用的问题
   - GC Roots
     - 虚拟机栈中引用的对象
     - 本地方法引用的对象
     - 方法区中类静态属性引用的对象
     - 方法区中常量引用的对象：字符串常量池
     - 被同步锁synchronized持有的对象
     - 居民内部的引用

### 3、finalization机制

- 垃圾回收之前调用finalize()方法，该方法允许在子类中被重写，用于在对象被回收时进行资源释放；
- 不建议主动调用
- 对象的三种状态：
  - 可触及的
  - 可复活的
  - 不可触及的

### 4、标记-清除算法（Mark - Sweep)

1. 从根节点出发开始遍历，**标记可达对象**
2. 将没有标记的对象清除

- 效率不算高
- GC时，需要stop the  world



### 5、复制算法

1. 将内存空间分成两块，先用一块，内存满之后；
2. 将可达对象，复制到另一个空间中

- 效率高
- 没有内存碎片问题
- 需要两倍的内存空间



### 6、标记 - 压缩/整理（Mark-Compact）

1. 遍历可达对象，标记存活对象
2. 清除垃圾之后，移动存活对象，压缩

- 没有内存碎片问题
- 没有内存减半的代价、
- 效率不如复制算法



### 7、分代收集算法

1. 年轻代：复制算法
2. 老年代：标记-清除/标记-压缩    混合使用
   - CMS回收器是老年代的回收器，利用标记-清除算法

### 8、增量收集算法

- 让垃圾收集线程和应用程序线程交替执行，避免了STW时间过长
- 每次只收集一小片区域
- 基础仍然是标记清除  和  复制算法
- 会提高垃圾回收的成本，造成系统吞吐量的下降

### 9、分区算法

- 将整个堆空间划分成连续不同的小区间
- 每个小区间独立使用，独自收集



### 10、散点

1. System.gc(); 调用Full GC；不一定会立即生效
2. 内存溢出（OOM）
3. 内存泄露（Memory Leak)
   - 对象不会被程序用到了，但是GC不能回收
4. Stop the World
5. 垃圾回收的并行与并发
6. 并发（Concurrent)
   - 一个处理器上，交替执行不同程序
7. 并行（Parallel)
   - 多个处理器，各自处理之间的程序
8. GC的并发与并行
   - 并行：ParNew
   - 串行：Serial
   - 并发：用户线程与GC线程同时执行
9. 安全点与安全区域
   - 安全点：特点位置，用户线程停下来，开始GC
   - 安全区域：在安全区域内，随时停，随时GC
   - 主动性中断
10. 引用
    - 强引用：永远不会回收
      - 可触及的
    - 软引用：内存不足即回收
      - 内存足够时，不会回收
    - 弱引用：发现即回收
    - 虚引用：对象回收跟踪，对象被回收之前会发系统通知
      - Phantom Reference
      - 和没有引用是一样的，不能通过引用得到对象



### 11、垃圾回收器

- 按线程数分：
  - 串行：单CPU
  - 并行：多CPU

- 按工作模式分：
  - 并发式：同时执行
  - 独占式：STW
- 按碎片处理方式分
  - 压缩式
  - 非压缩式
- 按工作内存区间分
  - 年轻代
  - 老年代



1. **吞吐量**：运行用户代码的时间占总运行时间的比例
2. **暂停时间**：STW的时间
3. 内存占用：堆区所占的内存大小

**标准：在最大吞吐量优先的情况下，降低停顿时间**

- 垃圾回收器分类
  - 串行：Serial、Serial **Old**
  - 并行：ParNew、Parallel Scavenge、Parallel **Old**
  - 并发：**CMS**、G1



11.1、**Serial**回收器：采用复制算法、串行回收、STW

​           **Serial Old**回收器：标记压缩，串行回收、STW

- 简单高效
- 适用于单核CPU



11.2、**ParNew**回收器：并行回收、复制算法、STW

​           Server模式下默认

- 多CPU适用
- 单CPU，不如Serial回收器
- 可和**CMS  /  Parallel Old**一起使用



11.3、**Parallel Scanvenge**：复制、并行、STW

- 吞吐量优先
- 自适应调节策略
- 适用于后台运算不需要太多交互的任务：订单处理、工资支付
- 和 **Parallel Old** 一起使用：标记压缩、STW



11.4、**CMS**（Concurrent Mark Sweep)

- 低延迟

- 并发收集器，垃圾收集线程与用户线程同时工作

- 标记清除算法

- 老年代使用

- ![image-20200817153724048](C:\Users\11437\AppData\Roaming\Typora\typora-user-images\image-20200817153724048.png)

  - 初始标记：只标记GC Roots能直接关联到的对象

  - 并发标记：直接关联对象开始遍历后续对象

  - 重新标记：修正上述标记产生变动的部分对象

    ​                    将并发标记中怀疑的垃圾确认一遍

  - 并发清理：清除

- 弊端
  - 内存碎片、无法存储大对象
  - 占用CPU，造成吞吐量降低
  - 无法处理浮动垃圾：并发标记中新产生的垃圾无法处理

- 与ParNew一起使用

**11.5、G1回收器：区域化分代式**

- 目标：在延迟可控的情况下获得尽可能高的吞吐量
- 把堆内存分割成多个不相关的区域
- 避免了全区域的垃圾回收
- 优先回收价值最大Regin
- 针对多核CPU

**优势**

1. 并行与并发兼具
   - 并行：多个GC线程同时工作，STW
   - 并发：G1与应用程序交替执行
2. 分代收集
   - 分为年轻代和老年代
   - 堆空间分为若干区域
3. 空间整合
   - 复制算法
4. 可预测停顿时间模型
   - 优先回收价值最大的Regin
   - 保证在有限的时间内获取近可能高的收集效率

**缺点**

1. 需要占用额外的内存空间、负载高
   - 记忆集：每个区域都有独自的记忆集，记录引用该区域的其他区域，避免了全表扫描
2. 小内存（6—8）CMS效率好



**G1回收过程**

1. 年轻代GC（STW）
2. 老年代并发标记过程（伴随 年轻代GC）
3. 混合回收
4. （如果需要Full GC 还是继续存在，如果G1失败，Full GC 备用）
